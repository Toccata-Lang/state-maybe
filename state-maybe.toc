
;; state-maybe monad with lazy comp*

(defn reduce-args [[arg & args] s final-result]
  (let [x (arg s)]
    (and x (let [[result new-s] (extract x)]
             (or (and (=* 0 (list-count args))
                      (maybe [(reverse (cons result final-result)) new-s]))
                 (reduce-args args new-s (cons result final-result)))))))

(defn -comp* [mv mvs s]
  (let [x (mv s)]
    (or x
        (let [mv (first mvs)]
          (and mv (-comp* (extract mv) (rest mvs) s))))))

(deftype new-sm [invoke-fn]
  Stringable
  (string-list [_] (comp (list "<new-sm ")
                         (string-list invoke-fn)
                         (list ">")))

  Function
  (invoke [ev s]
    (invoke-fn s))

  Container
  (map [_ f]
    (new-sm (fn [s]
              (let [x (invoke-fn s)]
                (and x (let [[v new-s] (extract x)]
                         (maybe [(f v) new-s])))))))
  (wrap [_ v]
    (new-sm (fn [s]
              (maybe [v s]))))
  (apply* [fv args]
    (new-sm (fn [s]
              (let [x (or (map (empty? args) (constantly [[] s]))
                          (reduce-args args s empty-list))]
                (and x (let [[results s] (extract x)
                             y (fv s)]
                         (and y (let [[f s] (extract y)]
                                  (or (and (empty? results)
                                           (maybe [(f) s]))
                                      (maybe [(apply f results) s]))))))))))
  (flat-map [ev f]
    (new-sm (fn [s]
              (let [x (invoke-fn s)]
                (and x (let [[v ss] (extract x)]
                         ((f v) ss)))))))

  Composition
  (zero [_] (new-sm (fn [_] nothing)))
  (comp* [mv mvs]
    (new-sm (fn [s]
              (-comp* mv mvs s)))))

(def state-maybe
  (reify
    Function
    (invoke [_ v]
      (new-sm (fn [s]
                (maybe [v s]))))

    Composition
    (zero [_] (new-sm (fn [_] nothing)))))

(defn lift [f]
  (fn [& args]
    (new-sm (fn [s]
              (maybe [(apply f args) s])))))

(defn update-state [f]
  (new-sm (fn [s]
            (maybe [s (f s)]))))

(defn get-val
  ([k]
     (new-sm (fn [s]
               (let [x (get s k)]
                 (and x (let [v (extract x)]
                          (maybe [v s])))))))
  ([k nf]
     (new-sm (fn [s]
               (or (let [x (get s k)]
                     (and x (let [v (extract x)]
                              (maybe [v s]))))
                   (maybe [nf s]))))))

(defn set-val [k v]
  (new-sm (fn [s]
            (maybe [nothing (assoc s k v)]))))

(defn get-in-val
  ([path]
     (new-sm (fn [s]
               (let [x (get-in s path)]
                 (and x (let [v (extract x)]
                          (maybe [v s])))))))
  ([path nf]
     (new-sm (fn [s]
               (or (let [x (get-in s path)]
                     (and x (let [v (extract x)]
                              (maybe [v s]))))
                   (maybe [nf s]))))))

(defn assoc-in-val [path v]
  (new-sm (fn [s]
            (maybe [v (assoc-in s path v)]))))

(defn update-val [key f]
  (new-sm (fn [s]
            (let [x (get s key)]
              (and x (let [old-v (extract x)
                           y (update-in s [key] f)]
                       (and y (let [new-s (extract y)]
                                (maybe [old-v new-s])))))))))

(defn update-in-val [path f]
  (new-sm (fn [s]
            (let [x (get-in s path)]
              (and x (let [old-v (extract x)
                           y (update-in s path f)]
                       (and y (let [new-s (extract y)]
                                (maybe [old-v new-s])))))))))

(defn recur-fn [f as s]
  (let [x (f s)]
    (or (and (= nothing x)
             (maybe [as s]))
        (let [[v ss] (extract x)]
          (recur-fn f (cons v as) ss)))))

(defn recur [mv]
  (new-sm (fn [s]
            (let [x (mv s)]
              (and x (let [[v ss] (extract x)
                           y (recur-fn (.invoke-fn mv) (list v) ss)]
                       (and y (let [[vs s] (extract y)]
                                (maybe [(reverse vs) s])))))))))

(defn when [val]
  (new-sm (fn [s]
            (and val (let [v (extract val)]
                       (maybe [v s]))))))

(defn when-not [val]
  (new-sm (fn [s]
            (and (= nothing val)
                 (maybe [nothing s])))))
